---
- name: Export snapshots of virtual machines
  hosts: "{{ (_run_condition | bool) | ternary('hypervisor', 'none') }}"
  gather_facts: yes
  any_errors_fatal: true
  vars:
    vm_prefix: "{{ provision.prefix | default('') }}"
    src_workspace: "{{ lookup('env', 'WORKSPACE') | default('/tmp', true) }}"
  tasks:
    - name: Install required packages
      package:
        name:
          - libguestfs-tools-c
          #- parallel TODO: not always available
        state: present

    - name: Get info about existing VM's
      virt:
        command: list_vms
      register: _virt_list

    - name: Create the list of VM's to operate on
      set_fact:
        _vm_list: "{{ _virt_list.list_vms | select('match', vm_prefix ~ provision.virsh.snapshot.servers) | list }}"

# TODO: detect cephfs, override path if detected? Maybe no, maybe use param rather?

#    - name: If RBD is used, overwrite snapshot destination
#      set_fact:
#        provision.virsh.snapshot.path: "/mnt/mycephfs"

    # TODO - figure this out - possibly replace with while loop or test disk1.os = True
    - name: Shut down any running VM's
      shell: |
        set -eo pipefail
        RETURN_CODE=0
        if ! virsh domstate {{ item }} | grep -qw 'shut off'; then
          virsh shutdown {{ item }}
          sleep 5
          virsh destroy {{ item }} || true
          RETURN_CODE=2
        fi
        exit ${RETURN_CODE}
      args:
        executable: /bin/bash
      loop: "{{ _vm_list }}"
      register: _vm_stop
      changed_when: _vm_stop.rc == 2
      failed_when: _vm_stop.rc not in [0, 2]

# TODO ADD ACPI checks for VMs that do not have OS yet...

    - name: Wait for all VM's to be shut down
      command: |
        virsh domstate {{ item }}
      changed_when: False
      register: _vm_shutdown
      until: _vm_shutdown.stdout.find('shut off') != -1
      retries: "{{ vm_shutdown_timeout | default(30) }}"
      delay: 10
      loop: "{{ _vm_list }}"

#    - name: Fail
#      fail: msg="Reached stop"

    - name: Make sure that the snapshot path exists
      file:
        path: "{{ provision.virsh.snapshot.path }}"
        state: directory

    - name: Export the image set, but cleanup if any failure is encountered
      block:
        - name: Export the infrared workspace
          shell: |-
            IR_CMD="{{ (lookup('env', 'VIRTUAL_ENV') != '') | ternary(lookup('env', 'VIRTUAL_ENV') ~ '/bin/infrared', 'infrared') }}"
            ${IR_CMD} workspace export --copy-keys --filename {{ src_workspace }}/infrared-workspace
          delegate_to: localhost
          args:
            executable: /bin/bash

        - name: Copy the exported workspace to the target host's snapshot export path
          copy:
            src: "{{ src_workspace }}/infrared-workspace.tgz"
            dest: "{{ provision.virsh.snapshot.path }}/"

        - name: Sparsify and export disk images
          shell: |
            for vdisk in $(virsh domblklist {{ item }} | awk '/{{ item }}/ {print $2}'); do
              virt-sparsify --in-place ${vdisk}
              qemu-img convert -O qcow2 -c ${vdisk} {{ provision.virsh.snapshot.path }}/${vdisk##*/}
            done
          args:
            executable: /bin/bash
          loop: "{{ _vm_list }}"
          when: not provision.rbd.on

        - name: Snapshot the states of all RBD images in image repository
          ignore_errors: yes
          shell: |
            echo "{{ provision.rbd.namespace }}" > "{{ provision.virsh.snapshot.path }}/namespace-info.txt"
            for vdisk in $(virsh domblklist {{ item }} | awk '/{{ item }}/ {print $2}'); do
              rbd snap create ${vdisk}@{{ provision.rbd.snapname }}
              rbd snap protect ${vdisk}@{{ provision.rbd.snapname }}
            done
          loop: "{{ _vm_list }}"
          when: provision.rbd.on

        - name: Save nvram image
          shell: |
            nvram_image=$(xmllint --xpath 'string(/domain/os/nvram)' /etc/libvirt/qemu/{{ item }}.xml)
            if [[ "${nvram_image}" != "" ]]; then
              rsync ${nvram_image} {{ provision.virsh.snapshot.path }}/
            fi
          args:
            executable: /bin/bash
          loop: "{{ _vm_list }}"
          when: not provision.rbd.on

        - name: Save VM definitions
          copy:
            src: "/etc/libvirt/qemu/{{ item }}.xml"
            dest: "{{ provision.virsh.snapshot.path }}/"
            remote_src: yes
          loop: "{{ _vm_list }}"

        - name: Find all the files for the manifest
          find:
            paths: "{{ provision.virsh.snapshot.path }}"
            patterns:
              - "*.qcow2"
              - "*.xml"
              - "*.tgz"
              - "*.fd"
            get_checksum: yes
          register: _virsh_snapshot_manifest_files

        - name: Prepare the manifest file content
          set_fact:
            _virsh_snapshot_manifest_content: >-
              {
                'virt_pool_path': '{{ provision.disk.pool }}',
                'snapshot_path': '{{ provision.virsh.snapshot.path }}',
                'hypervisor_fqdn': '{{ ansible_fqdn }}',
                'servers': [
              {% for vm_state_result in _vm_stop.results %}
                  {
                    'name': '{{ vm_state_result.item }}',
                    'state': '{{ (vm_state_result is changed) | ternary("running", "shut off") }}'
                  },
              {% endfor %}
                ],
                'files': {{ _virsh_snapshot_manifest_files.files | json_query('[*].{path: path, checksum: checksum}') | sort(attribute='path') }}
              }

        - name: Write out the manifest file
          copy:
            content: "{{ _virsh_snapshot_manifest_content | to_nice_json }}"
            dest: "{{ provision.virsh.snapshot.path }}/manifest.json"
      rescue:
        - name: Clean up the snapshot path
          file:
            path: "{{ provision.virsh.snapshot.path }}"
            state: absent
          when:
            - provision.virsh.snapshot.cleanup | bool

        - name: Fail after the cleanup
          fail:
            msg: "The image set export failed."

    - name: Restart any VM's that were running
      virt:
        name: "{{ item.item }}"
        state: running
      when: item is changed
      loop: "{{ _vm_stop.results }}"
      loop_control:
        label: "{{ item.item }}"
