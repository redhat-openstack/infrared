# save current node to "{{ node_dict }}"
- include_vars:
    file: "{{ node.key }}"
    name: node_dict

- name: merge overriden settings to the separate var
  set_fact:
      topology_node: "{{ node_dict|default({}) | combine((override|default({})).get(node.key|basename|splitext|first, {}), recursive=True) }}"

- name: download base image for node
  vars:
      source: "{{ item.value.import_url|default('') or node_dict.import_url|default('') or url }}"
  get_url:
      # Use default url if unless disk has a different source
      url: "{{ source }}"
      # use original basename explicitly, otherwise, "force" doesn't work
      dest: "{{ base_image_path }}/{{ source | basename }}"
      # Download new images only.
      force: no
      validate_certs: "{{ url.startswith('https://url.corp.redhat.com/') | ternary(false, omit)}}"
      owner: qemu
      group: qemu
      timeout: 30
  register: download_image_result
  until: download_image_result.msg.find("Request failed") == -1
  retries: 5
  delay: 5
  with_dict: "{{ topology_node.disks }}"
  when: topology_node.disks|count > 0

- name: adjust base image for this run
  shell: |
      set -ex
      export LIBGUESTFS_BACKEND=direct
      virt-sysprep -a {{ item.dest }} \
          --operations dhcp-client-state,dhcp-server-state,net-hostname,net-hwaddr,udev-persistent-net

      virt-customize -a {{ item.dest }} \
      {% if not item.item.value.image_url|default('') %}
          --run-command 'yum remove -y cloud-init*' \
      {% endif %}
          --root-password password:redhat \
          --run-command 'echo "UseDNS no" >> /etc/ssh/sshd_config' \
          --mkdir /root/.ssh \
          --chmod 0700:/root/.ssh \
          --upload /root/.ssh/id_rsa.pub:/root/.ssh/authorized_keys \
          --delete /etc/dhcp/dhclient.conf \
          --selinux-relabel
  with_items: "{{ download_image_result.results }}"
  when: item is changed

- name: set path of this run's base image (if no image customisations requested)
  set_fact:
      thisrun_image_path: "{{ download_image_result.results[0].dest }}"
  when: provision.get('images', {}).get('packages', {}) == {}

- block:
    - name: set run's datetime fact
      set_fact:
          run_datetime: "{{ ansible_date_time.year + ansible_date_time.month + ansible_date_time.day +
           '_' + ansible_date_time.hour + ansible_date_time.minute + ansible_date_time.second }}"

    - name: set path of this run's base image (if image customisations requested)
      set_fact:
          thisrun_image_path: "{{ download_image_result.results[0].dest | dirname }}/{{ (download_image_result.results[0].dest | basename | splitext)[0] }}_{{ run_datetime }}{{ (download_image_result.results[0].dest | basename | splitext)[1] }}"

    - name: check whether the base image for this run already exists
      stat:
          path: "{{ thisrun_image_path }}"
      register: thisrun_image_path_stat

    - name: 'create a base image file used only by this run (required for customisations, i.e.: image-packages)'
      copy:
        remote_src: True
        src: "{{ download_image_result.results[0].dest }}"
        dest: "{{ thisrun_image_path }}"
      when: thisrun_image_path_stat.stat.exists == false

  when: provision.get('images', {}).get('packages', {}) != {}

- name: Install packages in the base image for this run
  command: "virt-customize -a {{ thisrun_image_path }} --install {{ provision.images.packages }} --selinux-relabel"
  register: images_packages_run
  # we don't want to fail here, we want to get to next step to remove a left over image file
  ignore_errors: True
  when:
      - provision.get('images', {}).get('packages', {}) != {}
      - thisrun_image_path_stat.stat.exists == false

- name: remove this run's base image if something went wrong
  file:
      path: "{{ thisrun_image_path }}"
      state: absent
  when: images_packages_run.failed is defined and images_packages_run.failed == true
