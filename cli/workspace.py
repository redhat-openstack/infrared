from contextlib import contextmanager
import datetime
import time
import os
import shutil

from cli import exceptions
from cli import logger

LOG = logger.LOG

TIME_FORMAT = '%Y-%m-%d_%H-%M-%S'

LOCAL_HOSTS = """[local]
localhost ansible_connection=local ansible_python_interpreter=python
"""


class Workspace(object):
    INVENTORY_FILES = ["hosts", "inventory"]

    def __init__(self, path, inventory=None, ansible_cfg=None):
        self.name = os.path.basename(path)
        self.path = path
        self.inventory = inventory
        # Ansible config can be in user or system paths
        if ansible_cfg:
            self.ansible_cfg = ansible_cfg
        self._create_symlinks()

    def _create_symlinks(self):
        """symlink all IR libraries"""
        LIBS = ["library", "playbooks", "plugins", "roles", "settings",
                "templates"]
        for lib in LIBS:
            try:
                self.get(lib)
                continue
            except exceptions.IRWorkspaceMissingFile:
                os.symlink(os.path.abspath(lib), self._filename(lib))

    def _filename(self, filename):
        """Helper function. construct path without validation"""
        return os.path.join(self.path, filename)

    def get(self, filename):
        """get a path to file in workspace"""
        path = self._filename(filename)
        if os.path.exists(path):
            return path
        raise exceptions.IRWorkspaceMissingFile(
            workspace=self.name, filename=filename
        )

    # todo(yfried): consider using Ansible inventory object
    @property
    def inventory(self):
        return self._inventory

    @inventory.setter
    def inventory(self, path):
        """Set inventory file.

        if provided, copy file into workspace as "inventory"

        else, search workspace for files generated by infrared (will have
        "hosts" as symlink to file)

        If not file, write LOCAL_HOST template to workspace
        """
        _symlink = "hosts"
        if path:
            LOG.debug("Import inventory file {}".format(path))
            shutil.copy2(path, self.path)
            self._inventory = self.get(os.path.basename(path))
            # self._inventory = self._filename("inventory")
            # shutil.copyfile(path, self._inventory)
        else:
            try:
                self._inventory = self.get(_symlink)
                LOG.debug("Found inventory file {} in workspace".format(
                    self._inventory))
                return
            except exceptions.IRWorkspaceMissingFile:
                LOG.debug("Create default inventory")
                self._inventory = self._filename("local_host")
                with open(self._inventory, 'w') as f:
                    f.write(LOCAL_HOSTS)
        os.symlink(self._inventory, self._filename(_symlink))

    # todo(yfried): consider using Ansible code to handle config
    @property
    def ansible_cfg(self):
        return self._ansible_cfg

    # todo(yfried): try symlink
    @ansible_cfg.setter
    def ansible_cfg(self, path):
        """Set ansible configuration file.

        Copy file into workspace as "ansible.cfg"
        """
        dst_filename = "ansible.cfg"
        LOG.debug("Import Ansible configuration file from {}".format(path))
        # shutil.copy2(path, self.path)
        # self._ansible_cfg = self._get(os.path.basename(path))
        self._ansible_cfg = self._filename(dst_filename)
        shutil.copyfile(path, self._ansible_cfg)

    @contextmanager
    def activate(self):
        old_dir = os.getcwd()
        os.chdir(self.path)
        try:
            yield
        finally:
            os.chdir(old_dir)


class WorkspaceManager(object):
    # todo(yfried): move to conf
    workspacedir = os.path.join(os.path.expanduser("~"), ".infrared",
                                "workspaces")
    _active = os.path.join(workspacedir, ".active")

    @classmethod
    def create(cls, name="", *args, **kwargs):
        """Create a new workspace."""
        name = name or "workspace_" + datetime.datetime.fromtimestamp(
            time.time()).strftime(TIME_FORMAT)
        path = os.path.join(WorkspaceManager.workspacedir, name)
        if os.path.exists(path):
            raise exceptions.IRWorkspaceExists(workspace=name)
        os.makedirs(path)
        LOG.debug("Workspace {} created in {}".format(name, path))
        cls._set_active(name)
        return Workspace(path=path, *args, **kwargs)

    @classmethod
    def delete(cls, name):
        path = os.path.join(WorkspaceManager.workspacedir, name)
        if not os.path.exists(path):
            raise exceptions.IRWorkspaceMissing(workspace=name)
        shutil.rmtree(path)
        LOG.debug("Workspace {} deleted".format(name))


    @classmethod
    def list(cls):
        """list existing workspaces."""
        # walk returns the basedir as well. need to remove it
        dirlist = [os.path.basename(d[0]) for d in os.walk(
            cls.workspacedir)][1:]
        return dirlist

    @classmethod
    def get(cls, name, *args, **kwargs):
        """Use an existing workspace."""
        path = os.path.join(WorkspaceManager.workspacedir, name)
        if os.path.exists(path):
            LOG.debug("Reusing workspace {} in {}".format(name, path))
            return Workspace(path, *args, **kwargs)
        else:
            raise exceptions.IRWorkspaceMissing(workspace=name)

    @classmethod
    def get_active(cls):
        """Return active workspace.

        Clean bad links if no active workspace is found

        :return: Workspace
        :raises: exceptions.IRWorkspaceNoActive
        """
        try:
            with open(cls._active) as wkspc_file:
                name = wkspc_file.read().strip()
                return cls.get(name)
        except exceptions.IRWorkspaceMissing:
            os.remove(cls._active)
        except IOError as e:
            if e.errno != 2:
                raise
        raise exceptions.IRWorkspaceNoActive

    @classmethod
    def _set_active(cls, name):
        with open(cls._active, 'w') as wkspc_file:
            wkspc_file.write(name)
        LOG.debug("Workspace {} is now active".format(name))

    @classmethod
    def set_active(cls, name):
        """Set active workspace

        :param name: workspace name.
        :return: Workspace. Active workspace object
        """
        res = cls.get(name)
        cls._set_active(name)
        return res
