import datetime
import shutil
import time
import os

from cli import conf
from cli import exceptions
from cli import logger

LOG = logger.LOG

TIME_FORMAT = '%Y-%m-%d_%H-%M-%S'

LOCAL_HOSTS = """[local]
localhost ansible_connection=local ansible_python_interpreter=python
"""


class Profile(object):
    INVENTORY_FILES = ["hosts", "inventory"]

    def __init__(self, path, inventory=None, ansible_cfg=None):
        self.name = os.path.basename(path)
        self.path = path
        self.inventory = inventory
        # Ansible config can be in user or system paths
        # if ansible_cfg:
        #     self.ansible_cfg = ansible_cfg
        self._create_symlinks()

    def _create_symlinks(self):
        """symlink all IR libraries"""
        LIBS = ["library", "playbooks", "plugins", "roles", "settings",
                "templates"]
        for lib in LIBS:
            try:
                self.get(lib)
                continue
            except exceptions.IRProfileMissingFile:
                os.symlink(os.path.abspath(lib), self._filename(lib))

    def _filename(self, filename):
        """Helper function. construct path without validation"""
        return os.path.join(self.path, filename)

    def get(self, filename):
        """get a path to file in profile"""
        path = self._filename(filename)
        if os.path.exists(path):
            return path
        raise exceptions.IRProfileMissingFile(
            profile=self.name, filename=filename
        )

    # todo(yfried): consider using Ansible inventory object
    @property
    def inventory(self):
        return self._inventory

    @inventory.setter
    def inventory(self, path):
        """Set inventory file.

        if provided, copy file into profile as "inventory"

        else, search profile for files generated by infrared (will have
        "hosts" as symlink to file)

        If not file, write LOCAL_HOST template to profile
        """
        _symlink = "hosts"
        if path:
            LOG.debug("Import inventory file {}".format(path))
            shutil.copy2(path, self.path)
            self._inventory = self.get(os.path.basename(path))
            # self._inventory = self._filename("inventory")
            # shutil.copyfile(path, self._inventory)
        else:
            try:
                self._inventory = self.get(_symlink)
                LOG.debug("Found inventory file {} in profile".format(
                    self._inventory))
                return
            except exceptions.IRProfileMissingFile:
                LOG.debug("Create default inventory")
                self._inventory = self._filename("local_host")
                with open(self._inventory, 'w') as f:
                    f.write(LOCAL_HOSTS)
        os.symlink(os.path.basename(self._inventory), self._filename(_symlink))

    # todo(yfried): consider using Ansible code to handle config
    @property
    def ansible_cfg(self):
        return self._ansible_cfg

    # todo(yfried): try symlink
    @ansible_cfg.setter
    def ansible_cfg(self, path=None):
        """Set Ansible configuration file.

        Copy file into profile as "ansible.cfg"
        """
        dst_filename = "ansible.cfg"
        if path:
            LOG.debug("Import Ansible configuration file from {}".format(path))
            # shutil.copy2(path, self.path)
            # self._ansible_cfg = self._get(os.path.basename(path))
            self._ansible_cfg = self._filename(dst_filename)
            shutil.copyfile(path, self._ansible_cfg)
        else:
            try:
                self._ansible_cfg = self.get(dst_filename)
            except exceptions.IRProfileMissingFile:
                self._ansible_cfg = None


class ProfileManager(object):
    # TODO(yfried): Enable when profiles becomes mandatory
    # _default_profiledir = os.path.join(os.path.expanduser("~"), ".infrared",
    #                                    "profiles")
    _profiledir = None
    _config = None

    @classmethod
    def _get_profiledir(cls):
        if cls._profiledir:
            return cls._profiledir
        # todo(yfried): improve conf handling
        cls._config = cls._config or conf.ConfigWrapper.load_config_file()
        cls._profiledir = cls._config.get_profiles_dir()

        # TODO(yfried): Enable when profiles becomes mandatory
        # cls._profiledir = cls._config.get_profiles_dir() or \
        #     cls._default_profiledir
        # TODO(yfried): Remove when profiles becomes mandatory
        if not cls._profiledir:
            raise exceptions.IRProfileUndefined

        return cls._profiledir

    @classmethod
    def create(cls, name="", *args, **kwargs):
        """Create a new profile."""
        name = name or "profile_" + datetime.datetime.fromtimestamp(
            time.time()).strftime(TIME_FORMAT)
        path = os.path.join(cls._get_profiledir(), name)
        if os.path.exists(path):
            raise exceptions.IRProfileExists(profile=name)
        os.makedirs(path)
        LOG.debug("Profile {} created in {}".format(name, path))
        cls._set_active(name)
        return Profile(path=path, *args, **kwargs)

    @classmethod
    def delete(cls, name):
        path = os.path.join(cls._get_profiledir(), name)
        if not os.path.exists(path):
            raise exceptions.IRProfileMissing(profile=name)
        shutil.rmtree(path)
        LOG.debug("Profile {} deleted".format(name))

    @classmethod
    def list(cls):
        """list existing profiles."""
        # walk returns the basedir as well. need to remove it
        dirlist = [os.path.basename(d[0]) for d in os.walk(
            cls._get_profiledir())][1:]
        return dirlist

    @classmethod
    def get(cls, name, *args, **kwargs):
        """Use an existing profile."""
        path = os.path.join(cls._get_profiledir(), name)
        if os.path.exists(path):
            LOG.debug("Reusing profile {} in {}".format(name, path))
            return Profile(path, *args, **kwargs)
        else:
            raise exceptions.IRProfileMissing(profile=name)

    @classmethod
    def get_active(cls):
        """Return active profile.

        Clean bad links if no active profile is found

        :return: Profile
        :raises: exceptions.IRProfileNoActive
        """
        try:
            with open(os.path.join(cls._get_profiledir(),
                                   ".active")) as prf_file:
                name = prf_file.read().strip()
                return cls.get(name)
        except exceptions.IRProfileMissing:
            os.remove(os.path.join(cls._get_profiledir(), ".active"))
        except IOError as e:
            if e.errno != 2:
                raise

    @classmethod
    def _set_active(cls, name):
        """Helper method to set active without invoking "get()" """
        with open(os.path.join(cls._get_profiledir(),
                               ".active"), 'w') as prf_file:
            prf_file.write(name)
        LOG.debug("Profile {} is now active".format(name))

    @classmethod
    def set_active(cls, name):
        """Set active profile

        :param name: profile name.
        :return: Profile. Active profile object
        """
        res = cls.get(name)
        cls._set_active(name)
        return res
